<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pvplib.core &mdash; PVPlib 0.3.0-dev0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> PVPlib
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">See also</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">    Home page</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/pvplib.html">    API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PVPlib</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pvplib.core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pvplib.core</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">statsmodels.regression</span>
<span class="kn">import</span> <span class="nn">statsmodels.tools</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">opti</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">interp</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>


<div class="viewcode-block" id="PVP"><a class="viewcode-back" href="../../_autosummary/pvplib.core.PVP.html#pvplib.core.PVP">[docs]</a><span class="k">class</span> <span class="nc">PVP</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling_period</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span> <span class="o">=</span> <span class="n">sampling_period</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pvp_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_removed_outliers</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Duration: </span><span class="se">\t</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds </span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Number of trajectories: </span><span class="se">\t</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Outliers Removed: </span><span class="se">\t</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_removed_outliers</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_str</span> <span class="o">+=</span> <span class="s2">&quot;PVP stats: </span><span class="se">\t</span><span class="s2"> tau=</span><span class="si">{:.3f}</span><span class="s2">, sigma0=</span><span class="si">{:.2e}</span><span class="s2">, Dtau=</span><span class="si">{:.3f}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pvp_params</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_str</span> <span class="o">+=</span> <span class="s2">&quot;PVP fit: </span><span class="se">\t</span><span class="s2"> C=</span><span class="si">{:.2f}</span><span class="s2">, Omega = </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">_str</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">timestamps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pvp_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pvp_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;tau_index&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span><span class="p">),</span>
            <span class="s2">&quot;tau&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span><span class="p">,</span>
            <span class="s2">&quot;sigma_0&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span><span class="p">),</span>
            <span class="s2">&quot;Dtau&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_prof</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span><span class="p">)],</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pvp_params</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kinematic_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">T</span>

    <span class="nd">@kinematic_profile</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">kinematic_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of kinematic profiles should be of length 3 (time, dimension, number of movements) but it has length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span> <span class="o">=</span> <span class="n">item</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_reference_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span>

    <span class="k">def</span> <span class="nf">_remove_outliers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_outliers_k_sigma_away</span><span class="o">=</span><span class="mf">3.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;_remove_outliers</span>

<span class="sd">        Remove trajectory outliers, by removing all trajectories that are outside of the range (m +- k sigma), where m is the mean trajectory and sigma is the standard deviation of the set of trajectories.</span>


<span class="sd">        .. note:</span>
<span class="sd">            The formula above is based on the confidence interval for a Gaussian, and we apply it component per component. A true multivariate approach would use the confidence interval for a multivariate Gaussian see e.g. https://stats.stackexchange.com/questions/29860/confidence-interval-of-multivariate-gaussian-distribution</span>

<span class="sd">        :param remove_outliers_k_sigma_away: k, defaults to 3.5</span>
<span class="sd">        :type remove_outliers_k_sigma_away: float, optional</span>
<span class="sd">        :return: (index of removed trajectories in old array, new array)</span>
<span class="sd">        :rtype: tuple(list, array)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_indx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">remove_outliers_k_sigma_away</span>
        <span class="k">for</span> <span class="n">ncomp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span><span class="p">[:,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">std</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span><span class="p">[:,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">_traj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span><span class="p">[:,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="p">:]):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">_traj</span> <span class="o">&gt;</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">std</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">_traj</span> <span class="o">&lt;</span> <span class="n">mean</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">std</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">_indx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">_indx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">_indx</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="p">,</span> <span class="n">_indx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_profiles</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_removed_outliers</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_indx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_indx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span>

<div class="viewcode-block" id="PVP.plot_std_profiles"><a class="viewcode-back" href="../../_autosummary/pvplib.core.PVP.html#pvplib.core.PVP.plot_std_profiles">[docs]</a>    <span class="k">def</span> <span class="nf">plot_std_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prof_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;plot_std_profiles</span>

<span class="sd">        Plots the standard deviation profiles on the provided axis. If not provided, will create a new figure from scratch.</span>
<span class="sd">        If fit is True, will also compute the spline fit to the second and third phase. Keyword arguments to the std plotter (prof_kwargs) and to the fit plotter (fit_kwargs) can also be given.</span>

<span class="sd">        .. note::</span>

<span class="sd">            You should have fitted the profiles prior to plotting them.</span>

<span class="sd">        :param ax: axis on which to draw, defaults to None. If None, creates a new figure and axis to draw on.</span>
<span class="sd">        :type ax: plt.axis, optional</span>
<span class="sd">        :param fit: whether to plot the spline fit, defaults to True</span>
<span class="sd">        :type fit: bool, optional</span>
<span class="sd">        :param prof_kwargs: keyword arguments are passed to plotter for the standard deviation profile, defaults to None</span>
<span class="sd">        :type prof_kwargs: dict, optional</span>
<span class="sd">        :param fit_kwargs: keyword arguments are passed to plotter for the spline fit, defaults to None</span>
<span class="sd">        :type fit_kwargs: dict, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">prof_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">prof_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">prof_kwargs</span>
        <span class="n">fit_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">fit_kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">fit_kwargs</span>

        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;k-&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;PVP&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">prof_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fit</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pvp_fit_x</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pvp_fit_y</span><span class="p">,</span>
                <span class="s2">&quot;r-&quot;</span><span class="p">,</span>
                <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Spline fit&quot;</span><span class="p">,</span>
                <span class="o">**</span><span class="n">fit_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;$\tau = </span><span class="si">{:.3f}</span><span class="s2">, C = {{</span><span class="si">{:.1f}</span><span class="s2">}}, \Omega = </span><span class="si">{:.1f}</span><span class="s2">$&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pvp_params</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">visible</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">which</span><span class="o">=</span><span class="s2">&quot;minor&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\sigma\mathrm{(t) (m)}$&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_compute_mean_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mean_prof_incr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_signal</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mean_prof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean_prof_incr</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mean_prof</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mean_prof_incr</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mean_prof</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_prof</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_prof</span>

    <span class="k">def</span> <span class="nf">_compute_std_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_std_prof_incr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_reference_signal</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_std_prof_incr</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_std_prof_incr</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span>

<div class="viewcode-block" id="PVP.compute_profiles"><a class="viewcode-back" href="../../_autosummary/pvplib.core.PVP.html#pvplib.core.PVP.compute_profiles">[docs]</a>    <span class="k">def</span> <span class="nf">compute_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;compute_profiles</span>

<span class="sd">        Computes the mean and standard deviation profiles for a set of trajectories.</span>

<span class="sd">        :return: (mean profile, standard deviation profile)</span>
<span class="sd">        :rtype: tuple(array, array)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_mean_profile</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_std_profile</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_prof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span></div>

<div class="viewcode-block" id="PVP.compute_pvp"><a class="viewcode-back" href="../../_autosummary/pvplib.core.PVP.html#pvplib.core.PVP.compute_pvp">[docs]</a>    <span class="k">def</span> <span class="nf">compute_pvp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_outliers_k_sigma_away</span><span class="o">=</span><span class="mf">3.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;compute_pvp</span>

<span class="sd">        Run the full PVP routine:</span>

<span class="sd">            + compute profiles</span>
<span class="sd">            + remove outliers k sigma away</span>
<span class="sd">            + fit profiles</span>

<span class="sd">        :param remove_outliers_k_sigma_away: remove outliers k sigma away, defaults to 3.5</span>
<span class="sd">        :type remove_outliers_k_sigma_away: float, optional</span>
<span class="sd">        :return: standard deviation profile, x and y values of the fit, kinematic profiles</span>
<span class="sd">        :rtype: tuple(array, array, array, array)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">std_prof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_profiles</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">kinematic_profiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_outliers</span><span class="p">(</span>
            <span class="n">remove_outliers_k_sigma_away</span><span class="o">=</span><span class="n">remove_outliers_k_sigma_away</span>
        <span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">fit_x</span><span class="p">,</span> <span class="n">fit_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_profiles</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">std_prof</span><span class="p">,</span> <span class="n">fit_x</span><span class="p">,</span> <span class="n">fit_y</span><span class="p">,</span> <span class="n">kinematic_profiles</span></div>

    <span class="k">def</span> <span class="nf">_fit_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">optim_kwargs</span><span class="p">):</span>

        <span class="c1">### Define cost function for optimization procedure</span>
        <span class="k">def</span> <span class="nf">monospline</span><span class="p">(</span><span class="n">THETA</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mt</span> <span class="o">=</span> <span class="n">THETA</span>
            <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">mt</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">v</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">mt</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="c1">## Once Omega has been determined, run a classical LR on the second phase to get LR diagnostics</span>
        <span class="k">def</span> <span class="nf">get_fit_second_phase</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indx_omega</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">indx_omega</span><span class="p">)]</span>
            <span class="n">yy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="n">indx_omega</span><span class="p">]</span>
            <span class="n">xx</span> <span class="o">=</span> <span class="n">statsmodels</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">statsmodels</span><span class="o">.</span><span class="n">regression</span><span class="o">.</span><span class="n">linear_model</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">yy</span><span class="p">,</span> <span class="n">xx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">second_phase_fit</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_phase_fit</span>

        <span class="n">indx_tau</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">sigma0</span><span class="p">,</span> <span class="n">Dtau</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvp_params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="c1">### Initialize optimization algorithm - Data and start parameters</span>
        <span class="n">theta0</span> <span class="o">=</span> <span class="n">optim_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s2">&quot;spline_param_guess&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">sigma0</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># should work for most cases</span>
        <span class="k">if</span> <span class="n">indx_tau</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="n">indx_tau</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span><span class="p">[</span><span class="n">indx_tau</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span><span class="p">)</span>

        <span class="c1">## Global Optimization</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="n">optim_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;basinhopping_n_iter&quot;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">opti</span><span class="o">.</span><span class="n">basinhopping</span><span class="p">(</span>
            <span class="n">func</span><span class="o">=</span><span class="n">monospline</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">theta0</span><span class="p">,</span>
            <span class="n">niter</span><span class="o">=</span><span class="n">n_iter</span><span class="p">,</span>
            <span class="n">minimizer_kwargs</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
                <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="s2">&quot;disp&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
            <span class="p">},</span>
        <span class="p">)</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span>
        <span class="n">c0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">get_fit_second_phase</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">c0</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>

        <span class="n">_yy</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c0</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span>
            <span class="n">a</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">b</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indx_tau</span><span class="p">:]))</span>
        <span class="p">]</span>
        <span class="n">_yy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">**</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_yy</span><span class="p">]</span>
        <span class="n">t_fit</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pvp_params</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">_yy</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvp_fit_x</span> <span class="o">=</span> <span class="n">t_fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvp_fit_y</span> <span class="o">=</span> <span class="n">_yy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvp_params</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">]]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvp_fit_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvp_fit_y</span>

    <span class="k">def</span> <span class="nf">_extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajectory</span><span class="p">,</span> <span class="n">extend_to</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;_extend extend trajectories</span>

<span class="sd">        Extends the self._kinematic_profile buffer with a new trajectory while ensuring the series in the buffer always have the same size as the trajectory. For example, if the buffer has shape (X, Y) and the trajectory series has length (Z):</span>

<span class="sd">            + if Z &gt; Y, then the buffer is filled with the last values to reach shape (X, Z)</span>
<span class="sd">            + if Z &lt; Y, then the trajectory is filled with the last value to reach shape (1, Y)</span>

<span class="sd">        The minimum duration of the series can be set with extend_to.</span>

<span class="sd">        :param trajectory: trajectory to add to the self._kinematic_profile buffer</span>
<span class="sd">        :type trajectory: array_like</span>
<span class="sd">        :param extend_to: minimum duration of the series in seconds, defaults to 3</span>
<span class="sd">        :type extend_to: int, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">trajectory</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># First traj</span>
            <span class="n">Nmin</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">extend_to</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">Nmin</span><span class="p">:</span>
                <span class="n">fill</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">Nmin</span> <span class="o">-</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">trajectory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                <span class="p">)</span>
                <span class="n">trajectory</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">trajectory</span><span class="p">,</span> <span class="n">fill</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">trajectory</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">fill</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span>
                        <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">),</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="p">,</span> <span class="n">fill</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">fill</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="p">),</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">trajectory</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                <span class="p">)</span>
                <span class="n">trajectory</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">trajectory</span><span class="p">,</span> <span class="n">fill</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">trajectory</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span>

    <span class="k">def</span> <span class="nf">_find_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;speed_threshold&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;_find_start correct start</span>

<span class="sd">        Trajectories may not always be consistently segmented. This function performs a correction for the start point, as indicated by the method.</span>

<span class="sd">            + method = &#39;speed_threshold&#39; :</span>
<span class="sd">                Computes a threshold for speed as x_percent * max speed. All points the target and the first time when the threshold is crossed are removed.</span>
<span class="sd">                \*\*kwargs = {&#39;percent&#39; : x_percent}</span>

<span class="sd">        :param container: output from add_traj</span>
<span class="sd">        :type container: numpy.ndarray</span>
<span class="sd">        :param method: method to correct start, defaults to &quot;speed_threshold&quot;</span>
<span class="sd">        :type method: str, optional</span>
<span class="sd">        :return: trajectory with correction for speed</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time</span><span class="p">,</span> <span class="n">traj</span><span class="p">,</span> <span class="n">speed</span> <span class="o">=</span> <span class="n">container</span>

        <span class="n">indx</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;speed_threshold&quot;</span><span class="p">:</span>
            <span class="c1">### Removes points until having reached a speed that is 1% of the max speed.</span>
            <span class="n">max_speed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">speed</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">percent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;percent&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">speed</span><span class="p">[</span><span class="n">indx</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">max_speed</span> <span class="o">*</span> <span class="n">percent</span> <span class="o">/</span> <span class="mi">100</span><span class="p">:</span>
                <span class="n">indx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Only method speed_threshold is implemented for now.&quot;</span>
            <span class="p">)</span>

        <span class="n">container</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="n">indx</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">traj</span><span class="p">[</span><span class="n">indx</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">container</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">container</span><span class="p">,</span> <span class="n">speed</span><span class="p">[</span><span class="n">indx</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">container</span><span class="p">,</span> <span class="n">indx</span>

<div class="viewcode-block" id="PVP.plot_kinematic_profiles"><a class="viewcode-back" href="../../_autosummary/pvplib.core.PVP.html#pvplib.core.PVP.plot_kinematic_profiles">[docs]</a>    <span class="k">def</span> <span class="nf">plot_kinematic_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;plot_kinematic_profiles</span>

<span class="sd">        Plots the kinematic profiles on the provided axis. If not provided, will create a new figure from scratch.</span>

<span class="sd">        :param ax: axis on which to draw, defaults to None. If None, creates a new figure and axis to draw on.</span>
<span class="sd">        :type ax: plt.axis, optional</span>
<span class="sd">        :param **kwargs: keyword arguments are passed to plt.plot()</span>
<span class="sd">        :type **kwargs: key-values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span><span class="p">[:,</span> <span class="n">k</span><span class="p">,</span> <span class="p">:]:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Position&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PVP.add_trajectory"><a class="viewcode-back" href="../../_autosummary/pvplib.core.PVP.html#pvplib.core.PVP.add_trajectory">[docs]</a>    <span class="k">def</span> <span class="nf">add_trajectory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">extend_to</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">correct_start</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add trajectory to the set from which PVPs are computed</span>

<span class="sd">        Pass the time series, and any number of positional series. For example in dim3 with x, y, z, you would call (with defaults kwargs)</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            pvp.add_trajectory(t, x, y, z, extend_to = 3, target = None, correct_start = False)</span>

<span class="sd">        You control the duration of the PVP (e.g. how far in time trajectories are extended). You also need to specify the target location for each trajectory. You can optionally synchronize the trajectories by pre-processing them (correct_start). Currently, a simple thresholding rule takes care of this synchronization.</span>

<span class="sd">        :param t: time series</span>
<span class="sd">        :type t: numpy.array like</span>
<span class="sd">        :param args: positional series</span>
<span class="sd">        :type args: numpy.array like</span>
<span class="sd">        :param extend_to: minimal PVP duration, defaults to 3</span>
<span class="sd">        :type extend_to: int, optional</span>
<span class="sd">        :param target: target location, defaults to None. If None, will use the null vector as target.</span>
<span class="sd">        :type target: iterable, optional</span>
<span class="sd">        :param correct_start: whether to correct the location of the start of the movement for synchronization, defaults to False</span>
<span class="sd">        :type correct_start: bool, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span> <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">target</span>
        <span class="n">projections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp_filt</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
            <span class="o">*</span><span class="n">projections</span><span class="p">,</span>
            <span class="n">deriv</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">resampling_period</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">indx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">correct_start</span><span class="p">:</span>
            <span class="n">_norm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">tmp_container</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interp_filt</span><span class="p">(</span>
                <span class="n">container</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">_norm</span><span class="p">,</span>
                <span class="n">deriv</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">resampling_period</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_period</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">indx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_start</span><span class="p">(</span>
                <span class="n">tmp_container</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;speed_threshold&quot;</span><span class="p">,</span> <span class="n">percent</span><span class="o">=</span><span class="mi">2</span>
            <span class="p">)</span>
        <span class="n">container</span> <span class="o">=</span> <span class="n">container</span><span class="p">[:,</span> <span class="n">indx</span><span class="p">:,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_extend</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">extend_to</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_orthonormal_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bon1</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bon2</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bon3</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Dimensions above 3 are not supported yet. &quot;</span><span class="p">)</span>

    <span class="c1"># below does not reliably produce an orthonormal basis</span>
    <span class="c1"># switching to a manual cse disjunction up to 3D for now</span>

    <span class="c1"># def _get_orthonormal_basis(self, target, x0):</span>
    <span class="c1">#     target = numpy.asarray(target).squeeze()</span>
    <span class="c1">#     x0 = numpy.asarray(x0).squeeze()</span>
    <span class="c1">#     random_basis = numpy.array(</span>
    <span class="c1">#         [</span>
    <span class="c1">#             (target - x0),</span>
    <span class="c1">#             *[</span>
    <span class="c1">#                 -1 + 2 * numpy.random.random(x0.shape[0])</span>
    <span class="c1">#                 for v in range(x0.shape[0] - 1)</span>
    <span class="c1">#             ],</span>
    <span class="c1">#         ]</span>
    <span class="c1">#     ).T</span>
    <span class="c1">#     self.Q, _ = numpy.linalg.qr(random_basis)</span>
    <span class="c1">#     return self.Q</span>

    <span class="k">def</span> <span class="nf">_bon1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bon2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">v1</span><span class="p">],</span> <span class="p">[</span><span class="n">v2</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">_bon3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">x0</span><span class="p">):</span>
        <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bon2</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">vec3</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">vec3</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="nf">_project_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">target</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Q</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_orthonormal_basis</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">output</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_x</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="nf">_interp_filt</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">t</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">resampling_period</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">filter_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;filtername&quot;</span><span class="p">:</span> <span class="s2">&quot;kaiser&quot;</span><span class="p">,</span> <span class="s2">&quot;fc&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;rdb&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
        <span class="n">deriv</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;_interp_filt interpolates and filters a 1D trajectory</span>

<span class="sd">        Takes a trajectory, resamples it with the chosen resampling_period and filters it with the given filter. Also provides the unfiltered derivatives up to order &quot;deriv&quot;.</span>

<span class="sd">        :param t: trajectory time</span>
<span class="sd">        :type t: array like</span>
<span class="sd">        :param x: trajectory position</span>
<span class="sd">        :type x: array like</span>
<span class="sd">        :param resampling_period: timestep at which the trajectory will be down/over sampled, defaults to 0.01</span>
<span class="sd">        :type resampling_period: float, optional</span>
<span class="sd">        :param filter_kwargs: scipy.signal filter description, defaults to {&quot;filtername&quot;: &quot;kaiser&quot;, &quot;fc&quot;: 10, &quot;rdb&quot;: 10, &quot;width&quot;: 5}</span>
<span class="sd">        :type filter_kwargs: dict, optional</span>
<span class="sd">        :param deriv: order for the trajectory derivatives, defaults to 2</span>
<span class="sd">        :type deriv: int, optional</span>
<span class="sd">        :return: an array, where the first line is the time vector, and all other lines are the nth derivatives of the trajectory (0 &lt;= n &lt;= deriv).</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># set null time target</span>
        <span class="n">Ts</span> <span class="o">=</span> <span class="n">resampling_period</span>
        <span class="n">output_container</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">interpolator</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span><span class="p">)</span>
            <span class="n">resampling_instants</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">Ts</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">Ts</span><span class="p">),</span>
                <span class="n">num</span><span class="o">=</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">Ts</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">Ts</span><span class="p">))</span> <span class="o">/</span> <span class="n">Ts</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">x_interp</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">resampling_instants</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">filter_kwargs</span><span class="p">[</span><span class="s2">&quot;filtername&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;kaiser&quot;</span><span class="p">:</span>
                <span class="n">N</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">kaiserord</span><span class="p">(</span>
                    <span class="n">filter_kwargs</span><span class="p">[</span><span class="s2">&quot;rdb&quot;</span><span class="p">],</span> <span class="n">filter_kwargs</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Ts</span>
                <span class="p">)</span>
                <span class="n">taps</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">firwin</span><span class="p">(</span>
                    <span class="n">N</span><span class="p">,</span> <span class="n">filter_kwargs</span><span class="p">[</span><span class="s2">&quot;fc&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Ts</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;kaiser&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">filtered_x</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">taps</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x_interp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">filter_kwargs</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">],</span> <span class="n">filter_kwargs</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span>
                <span class="n">filtered_x</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">x_interp</span><span class="p">)</span>

            <span class="n">container</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">resampling_instants</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">filtered_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

            <span class="c1">## Compute derivatives</span>
            <span class="n">resampling_instants</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">resampling_instants</span><span class="p">,</span> <span class="n">resampling_instants</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ts</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deriv</span><span class="p">):</span>
                <span class="n">filtered_x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">filtered_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                        <span class="n">filtered_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                    <span class="p">),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">filtered_x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">filtered_x</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">resampling_instants</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">container</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">container</span><span class="p">,</span> <span class="n">filtered_x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output_container</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">container</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">output_container</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">output_container</span><span class="p">,</span> <span class="n">container</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">output_container</span></div>


<div class="viewcode-block" id="PVP_alpha"><a class="viewcode-back" href="../../_autosummary/pvplib.core.PVP_alpha.html#pvplib.core.PVP_alpha">[docs]</a><span class="k">class</span> <span class="nc">PVP_alpha</span><span class="p">(</span><span class="n">PVP</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_reference_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="PVP_total"><a class="viewcode-back" href="../../_autosummary/pvplib.core.PVP_total.html#pvplib.core.PVP_total">[docs]</a><span class="k">class</span> <span class="nc">PVP_total</span><span class="p">(</span><span class="n">PVP</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_reference_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span></div>


<div class="viewcode-block" id="PVP_generalized"><a class="viewcode-back" href="../../_autosummary/pvplib.core.PVP_generalized.html#pvplib.core.PVP_generalized">[docs]</a><span class="k">class</span> <span class="nc">PVP_generalized</span><span class="p">(</span><span class="n">PVP</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_reference_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinematic_profile</span>

    <span class="k">def</span> <span class="nf">_compute_std_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">std_prof</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">nt</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="p">):</span>
            <span class="n">cov</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cov</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">std_prof</span><span class="p">[</span><span class="n">nt</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cov</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span>
                    <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">std_prof</span><span class="p">[</span><span class="n">nt</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cov</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span> <span class="o">**</span> <span class="p">(</span>
                    <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kinematic_profile</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span> <span class="o">=</span> <span class="n">std_prof</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_prof</span></div>


<div class="viewcode-block" id="normalize"><a class="viewcode-back" href="../../_autosummary/pvplib.core.normalize.html#pvplib.core.normalize">[docs]</a><span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Anonymous.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>